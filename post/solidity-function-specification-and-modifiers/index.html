<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Solidity Function Visibility Specifications and Built-In Modifiers</title>
		<link rel="alternate" type="application/rss+xml" title="RSS" href="https://nataliechin80.github.io/index.xml">
		<link rel="canonical" href="https://nataliechin80.github.io/post/solidity-function-specification-and-modifiers/">
		<link rel="shortcut icon" type="image/png" href="https://nataliechin80.github.io/apple-touch-icon-precomposed.png">
		
		
		<meta name="generator" content="Hugo 0.55.6" />

		
		<meta property="og:title" content="Solidity Function Visibility Specifications and Built-In Modifiers" />
		<meta property="og:type" content="article" />
		<meta property="og:image" content="https://nataliechin80.github.io/img/erc20.jpg" />
		<meta property="og:description" content="" />
		<meta property="og:url" content="https://nataliechin80.github.io/post/solidity-function-specification-and-modifiers/" />
		<meta property="og:site_name" content="Solidity Function Visibility Specifications and Built-In Modifiers" />
		<meta name="twitter:card" content="summary_large_image" />
		<meta name="twitter:site" content="@" />


		
		<link rel="stylesheet" href="https://nataliechin80.github.io/css/tachyons.min.css" />
		<link rel="stylesheet" href="https://nataliechin80.github.io/css/story.css" />
		<link rel="stylesheet" href="https://nataliechin80.github.io/css/descartes.css" />
		
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
		<link href="https://fonts.googleapis.com/css?family=Quattrocento+Sans:400,400i,700,700i|Quattrocento:400,700|Spectral:400,400i,700,700i&amp;subset=latin-ext" rel="stylesheet">
		

		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
		
		<script src="https://nataliechin80.github.io/js/story.js"></script>

	</head>
	<body class="ma0 bg-white section-post page-kind-page is-page-true ">
		
		<header class="cover bg-top" style="background-image: url('https://nataliechin80.github.io/img/erc20.jpg'); background-position: center;">
				<div id="hdr" class="tc-l pv4-ns pv5-l pv2 ph3 ph4-ns">
					<h1 class="near-white mt1-ns f2 fw3 mb0 mt0 lh-title">Solidity Function Visibility Specifications and Built-In Modifiers</h1>
					<h2 class="near-white mt3-l mb4-l fw1 f6 f3-l subtitle measure-wide-l center lh-copy mt2 mb3">
						
						
							
								Published
								<time datetime="2020-05-08T11:17:05-04:00">May 8, 2020</time>
								<span class="display-print">by Natalie Chin</span>
								
								<span class="display-print">at https://nataliechin80.github.io/post/solidity-function-specification-and-modifiers/</span>
							
						
					</h2>
				</div>

				
				
				
				

			</div>

			<div class="bg-black-30 bb bt">
				<nav class="hide-print sans-serif  border-box pa3 ph5-l">
					<a href="https://nataliechin80.github.io" title="Home">
						<img src="https://nataliechin80.github.io/img/logo.jpg" class="w2 h2 br-100" alt="Natalie Chin" />
					</a>
					<div class="fr h2 pv2 tr">
						<a class="link f5 ml2 dim near-white" text-align = "centre" href="/">Home</a>
						<a class="link f5 ml2 dim near-white" text-align = "centre" href="/slides/">Slides</a>
						<a class="link f5 ml2 dim near-white" text-align = "centre" href="/talks/">Talks</a>
						<a class="link f5 ml2 dim near-white" href="mailto:natchin08@gmail.com"><i class="fas fa-envelope-open-text"></i></a>
						<a class="link f5 ml2 dim near-white" href="https://github.com/NatalieChin80"><i class="fab fa-github-square"></i></a>
						<a class="link f5 ml2 dim near-white" href="https://www.linkedin.com/in/nataliechin80"><i class="fab fa-linkedin"></i></a>
						<a class="link f5 ml2 dim near-white fas fa-rss-square" href="https://nataliechin80.github.io/index.xml" title="RSS Feed"></a>
						<a class="link f5 ml2 dim near-white fas fa-search" href="https://nataliechin80.github.io/search/" role="search" title="Search"></a>
					</div>
				</nav>

		</header>
		
		<main role="main">
		
<article class="center bg-white br-3 pv1 ph4 lh-copy f5 nested-links mw7">
	<p>What&rsquo;s the difference between Solidity Function Visibility (public, external, private, internal)? When should you use one over the other? How do you know when to use Solidity Modifiers (pure, view)? Read more to find out!</p>

<p>Solidity functions are usually of the following form, where it specifies a function visibility and a modifier attributed to a certain function. This blog goes into detailed function visibility specifiers (public, external, internal, private) and a few select modifiers (pure, view) that often cause confusion among developers.</p>

<pre><code>function functionName() [public | external | internal | private] {pure | view} returns (bool) {
    return true;
}
</code></pre>

<h1 id="function-visibility-keywords">Function Visibility Keywords</h1>

<p>In Solidity, there are 4 function visibility keywords, which are typically used in function definitions to explicitly state who should have access rights to a contract for a certain function. In many ways, these visibility keywords are similar to specifying access control on functions.</p>

<h2 id="public-functions">Public Functions</h2>

<p>The public keyword is used for functions where they can be called by any external account and any internal/external contract on the blockchain. This means that public functions are used in cases where a function is expected to provide information to anyone who calls it. A good example where a public function may be useful is in cases where variables are being accessed or overall state changes.</p>

<p>By looking at the <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L115">ERC20.sol</a> token implementation, there are a variety of functions that are public. An example of public functions in the standard are shown below:</p>

<pre><code>  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
    _transfer(_msgSender(), recipient, amount);
    return true;
  }
</code></pre>

<p>The <code>transfer()</code> function can be called by anyone with an external address (one in a wallet) and any contract to transfer token funds from the sender to a certain recipient. The public modifier on this function ensures that there are no access control restrictions on who can call this function.</p>

<h2 id="external-functions">External Functions</h2>

<p>External functions are set on functions that can only be called by an external account or external contract. This means, for a contract <code>A</code>, if it has a function <code>b()</code>, no functions in A can access <code>b()</code>. <code>b()</code> can be called by externally owned addresses or contracts that are not related to A, but the <code>external</code> keyword prevents all other functions in the same contract from calling it.</p>

<p>A prevalent example of external functions are in the <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L24">IERC20.sol</a> contracts, which are interfaces that specify the ERC20 implementation:</p>

<pre><code>    function transfer(address recipient, uint256 amount) external returns (bool);
</code></pre>

<p>Similar to interfaces in other object-oriented programming languages, interfaces define the behaviour of a certain contract and do not contain implementation details. The ERC20 Interface <code>transfer()</code> function specifies that the implementation contract must have a <code>transfer()</code> function, which takes the same arguments and returns the same values. The <code>external</code> specification ensures that the interface cannot call its own functions (which is not possible due to the interface not containing implementation). This does allow other contracts outside of this function to call this function.</p>

<h3 id="solidity-under-the-hood-for-public-and-external-functions-see-notes-at-the-end">Solidity: Under the Hood for Public and External Functions (see Notes at the end)</h3>

<p>Internal functions in Solidity are executed via JUMP, which means that the arguments for the function are expected to be located in memory. According to the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum Yellowpaper</a>, a JUMPDEST call uses 1 unit of gas.</p>

<p>External functions in Solidity do not use internal functions, thus do not need to keep arguments in memory. This information can be read from the CALLDATA of the transaction, as there&rsquo;s no need to store this in memory for another function to interact with.</p>

<p>When considering the construction and access control on public functions, one could reason that a public function is one that is external AND internal. This construction makes it significantly easier for us to understand why public functions consume more gas. Since public functions can be called by the contract itself, it will always save the arguments in memory. This means that the gas consumption by a public function should be expected to be higher than an external function.</p>

<h2 id="internal-functions">Internal Functions</h2>

<p>Internal functions can only be accessed by the contract the function resides in, and children of the contract. In the case of class hierarchy, this function can be called by inherited contracts but not external accounts or external contracts. These functions are typically helper functions, which is called by external/public functions.</p>

<p>By taking a look at the native <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol">ERC20.sol</a> token implementation on OpenZeppelin, there are two transferring functionalities (as seen in <code>transfer</code> and <code>transferFrom</code>). Both of these functions make use of the internal <code>_transfer()</code> functionality, which serves as a helper function for this contract and all other implemented inheritances of the ERC20 token (which has the added option of being Cappable, Pausable, etc).</p>

<p>Through this ERC20 token code, we can take a deeper look into what the difference between internal and public functions are:</p>

<pre><code>  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
    _transfer(_msgSender(), recipient, amount);
    return true;
  }
  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
    _transfer(sender, recipient, amount);
    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, &quot;ERC20: transfer amount exceeds allowance&quot;));
    return true;
  }
  function _transfer(address sender, address recipient, uint256 amount) internal virtual {
    require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);
    require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);

    _beforeTokenTransfer(sender, recipient, amount);

    _balances[sender] = _balances[sender].sub(amount, &quot;ERC20: transfer amount exceeds balance&quot;);
    _balances[recipient] = _balances[recipient].add(amount);
    emit Transfer(sender, recipient, amount);
  }
</code></pre>

<p>The <code>transferFrom()</code> and the <code>transfer()</code> function both have a public visibility on them, which ensures that these functions can be called by anyone. Both of these functions also call an internal <code>_transfer()</code> function, which performs the transfer functionality. The <code>_transfer()</code> function is a helper function to the other two functions, which provides the transfer implementations.</p>

<p>The <strong>internal</strong> visibility on the <code>_transfer()</code> function ensures that the function can only be called within the ERC20 Token Implementation. This ensures that external accounts and external contracts are unable to invoke this function.</p>

<h2 id="private-functions">Private Functions</h2>

<p>Functions with a private visibility are an even smaller subset of internal functions, specifying that the function can ONLY be called inside the contract itself. These functions are typically helper functions, with an even smaller scope of access control - limiting to the contract the code is located in. Private functions should be called by functions that have a wider access scope (such as internal, public, or external) - with the contents of the function calling a private function.</p>

<p>An example of a private function can be seen in <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20Snapshot.sol">ERC20Snapshot.sol</a> as part of the OpenZeppelin library, where the <code>_burn()</code> internal function invokes private functions in the contract.</p>

<pre><code>    function _burn(address account, uint256 value) internal virtual override {
        _updateAccountSnapshot(account);
        _updateTotalSupplySnapshot();

        super._burn(account, value);
    }
    function _updateAccountSnapshot(address account) private {
        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));
    }
    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {
        uint256 currentId = _currentSnapshotId.current();
        if (_lastSnapshotId(snapshots.ids) &lt; currentId) {
            snapshots.ids.push(currentId);
            snapshots.values.push(currentValue);
        }
    }
</code></pre>

<p>This example above demonstrates the expected flow of private functions, where the <code>_burn()</code> function can be invoked by any of the inherited ERC20 contracts. In the function, it calls a private helper function, which updates snapshot data on the ERC20 balances at a certain point in time. In this case, there was a specific design decision chosen to keep all snapshot functionality private to the <code>ERC20Snapshot.sol</code> file, since no other ERC20 implementations understand the concept of a snapshot.</p>

<h2 id="overview-of-function-visibility">Overview of Function Visibility</h2>

<p>The table below breaks down the differences between the function visibility.</p>

<table>
<thead>
<tr>
<th></th>
<th>Public</th>
<th>External</th>
<th>Internal</th>
<th>Private</th>
</tr>
</thead>

<tbody>
<tr>
<td>Description</td>
<td>Function can be called by <strong>anyone</strong></td>
<td>Function <strong>cannot</strong> be called by <code>this</code> contract</td>
<td>Function can be called by <code>this</code> contract and inherited contracts</td>
<td>Function can be called by <code>this</code> contract <strong>only</strong></td>
</tr>

<tr>
<td>Access Control</td>
<td>Wallet, <code>this</code> contract, External Contract</td>
<td>Wallet, External Contract</td>
<td><code>this</code> contract, Inherited Contracts</td>
<td><code>this</code> contract</td>
</tr>

<tr>
<td>Function Purpose</td>
<td>Getting state, changing state, calling helper</td>
<td>Getting state, changing state, calling helper</td>
<td>Helper function implementation</td>
<td>Helper function implementation</td>
</tr>
</tbody>
</table>

<p>Note: <code>this</code> contract refers to the contract where the function is written in, similar to how the Solidity language would support <code>address(this).balance</code>, which checks the Ether balance of <code>this</code> contract.</p>

<h1 id="solidity-function-modifiers">Solidity Function Modifiers</h1>

<p>Aside from function visibility specifiers, there is an important difference between pure and view modifiers that are provided by Solidity.</p>

<h2 id="view">View</h2>

<p>A function with a view modifier specifies that the function must never &ldquo;modify state&rdquo;. As this definition of &ldquo;modification of state&rdquo; can be ambiguous, here are a few actions which are <strong>not</strong> allowed in view functions:</p>

<ol>
<li>Writing to a variable in a contract - this implementation is <strong>saving state</strong>.</li>
<li>Emitting events - events are often emitted to notify event listeners that a contract state has changed</li>
<li>Sending Ether to another address - transferring Ether among addresses changes the state of the Ether balance</li>
<li>Calling a non view/pure function - all functions that a view function calls must also not change state of contracts</li>
<li>Using STATICCALL - similar to (4), where the implementation/function may change the state of an object/contract</li>
</ol>

<p>A good example of a view function is a getter function that returns state information from a certain contract. In <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L103">ERC20.sol</a>, there are a few getter functions, including retrieving token supply for a specific address:</p>

<pre><code>    mapping (address =&gt; uint256) private _balances;
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }
</code></pre>

<p>The <code>balanceOf()</code> function returns the token balance attributed to a given address, returning one of the entries in the <code>_balance</code> mapping.</p>

<h2 id="pure">Pure</h2>

<p>A function with a pure modifier specifies that the function must never modify AND access state. A <code>pure</code> modifier is stricter than a <code>view</code> modifier, which ensures that the internal state of a contract can never be accessed. In addition to the list of actions that view functions are not allowed to do, a pure function adds a few more:</p>

<ol>
<li>View or modify state - pure functions may perform calculations but are not allowed to access internal contract state</li>
<li>Accessing contract Ether balance - cannot perform checks related to balance of addresses</li>
<li>Unable to access block, tx, msg data - unable to access transaction information (<code>tx.origin</code>) or msg information (<code>msg.sender</code>)</li>
</ol>

<p>The specifications of a &ldquo;pure&rdquo; function are from functional programming, where the functions&rsquo; arguments define the scope. This means that the function must be able to execute solely with the arguments it has received, without accessing contract state or contract data.</p>

<p>A good example of a pure function is the <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol#L26">SafeMath</a> library, which provides mathematical checks to ensure that variables do not overflow/underflow after performing mathematical calculations such as adding:</p>

<pre><code>    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);

        return c;
    }
</code></pre>

<p>The <code>add()</code> function showcased above is a pure function, as it receives all the variables that it requires to check for overflow. Given the <code>uint256 a</code> and  <code>uint256 b</code>, the add function returns the result of the addition, given that the value has not overflowed.</p>

<hr />

<p>This wraps up the tutorial on the function visibility specifications that are available in native Solidity that allow developers more fine-tuned access control. The native Solidity modifiers (pure and view) provide the ability for us to define the expected behaviour of functionality, which allows smart contracts to be neater and easier to read.</p>

<h1 id="notes">Notes</h1>

<p>Thanks Mariano Conti for pointing out the gas difference between external and public functions!</p>

<h2 id="references">References</h2>

<ul>
<li><a href="https://ethereum.stackexchange.com/questions/19380/external-vs-public-best-practices">https://ethereum.stackexchange.com/questions/19380/external-vs-public-best-practices</a></li>
<li><a href="https://ethereum.stackexchange.com/questions/28813/how-to-write-an-optimized-gas-cost-smart-contract">https://ethereum.stackexchange.com/questions/28813/how-to-write-an-optimized-gas-cost-smart-contract</a></li>
<li><a href="https://ethereum.github.io/yellowpaper/paper.pdf">https://ethereum.github.io/yellowpaper/paper.pdf</a></li>
</ul>
</article>

		</main>
		
				<div class="hide-print sans-serif f6 f5-l mt5 ph3 pb6 center nested-copy-line-height lh-copy nested-links mw-100 measure-wide">
		<div class="about-the-author">
		
			
			
				
					<p>Natalie is a blockchain developer and blockchain professor, technical reviewer of Mastering Solidity, and an ambassador for females in technology.</p>

				
			
		
		</div>
		
	</div>

		
		
		
		<footer class="hide-print sans-serif f6 fw1 bg-black near-white bottom-0 w-100 pa3" role="contentinfo">
			<p class="w-50 fr tr">
			<a class="no-underline near-white" href="https://github.com/xaprb/story"><img class="dib" title="Made with Hugo and Story" alt="Story logo" src="https://nataliechin80.github.io/img/story-logo-white.svg" style="width: 1.5rem; height: 1.5rem" /></a>
			</p>
			<p class="w-50 near-white">
				&copy; 2020 Natalie Chin
			</p>
		</footer>
		
	
	
	</body>
</html>
